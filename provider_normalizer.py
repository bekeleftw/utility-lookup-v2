"""
Provider Name Normalizer

Normalizes utility provider names to canonical forms so that
"PG&E" and "Pacific Gas & Electric Company" are recognized as the same provider.

Single source of truth: reads from data/canonical_providers.json
(generated by consolidate_normalization.py).

The JSON schema distinguishes three relationships:
  1. ALIAS:          name variants that collapse to one canonical ID
  2. DISPLAY NAME:   consumer-facing brand shown in API responses
  3. PARENT COMPANY: corporate ownership metadata (NEVER used for matching)

Usage:
    from provider_normalizer import normalize_provider, providers_match
    
    # Normalize a name (returns the display_name)
    canonical = normalize_provider("Pacific Gas & Electric Company")  # "PG&E"
    
    # Check if two names match
    if providers_match("PG&E", "Pacific Gas & Electric Company"):
        print("Same provider!")
    
    # Get display name for API responses
    display = get_display_name("Pacific Gas & Electric Company")  # "PG&E"
"""

import json
import logging
import re
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)

try:
    from rapidfuzz import fuzz, process as rf_process
    _HAS_RAPIDFUZZ = True
except ImportError:
    _HAS_RAPIDFUZZ = False

_DATA_FILE = Path(__file__).parent / "data" / "canonical_providers.json"
_REPS_FILE = Path(__file__).parent / "data" / "deregulated_reps.json"

# Holding companies that should NEVER be returned as a provider name
# and should NEVER match via partial substring matching.
_HOLDING_COMPANIES = {
    "berkshire hathaway energy",
    "wec energy group",
    "southern company",
    "exelon",
    "nextera energy",
    "eversource energy",
    "entergy corporation",
    "firstenergy corp",
    "edison international",
    "sempra energy",
    "cms energy",
    "avangrid",
    "ppl corporation",
    "nisource",
    "agl resources",
    "scana",
}

# Null/placeholder values — not provider names, should not count as unmatched
_NULL_VALUES = {
    "n/a", "na", "none", "null", "unknown",
    "not needed", "not applicable", "not required",
    "landlord", "included", "included in rent",
    "choose your electric here", "choose texas power", "power to choose",
    "select", "enter", "tbd", "pending",
}

# Propane delivery companies — not regulated utilities
_PROPANE_COMPANIES = {
    "amerigas propane", "amerigas",
    "suburban propane",
    "direct propane",
    "superior plus propane", "superior propane",
    "mcphails",
    "ferrellgas", "ferrell gas",
}

# Fuzzy matching config
_FUZZY_MIN_SCORE = 85          # Minimum similarity threshold (0-100)
_SUBSTRING_MIN_LEN = 4         # Minimum alias length for substring matching

# Loaded at module init
_PROVIDER_DATA: dict = {}           # canonical_name -> {display_name, aliases[], parent_company?}
_ALIAS_TO_CANONICAL: dict = {}      # alias_lower -> canonical_name
_CANONICAL_TO_DISPLAY: dict = {}    # canonical_name -> display_name
_REP_ALIASES: dict = {}             # alias_lower -> rep_name (deregulated market REPs)
_FUZZY_CHOICES: list = []           # list of normalized alias strings for rapidfuzz
_FUZZY_CHOICE_MAP: dict = {}        # normalized_alias -> original alias key
_FUZZY_REP_CHOICES: list = []       # list of normalized REP name strings for rapidfuzz
_FUZZY_REP_MAP: dict = {}           # normalized_rep -> original rep alias key


def _load_data():
    """Load canonical_providers.json and build reverse index."""
    global _PROVIDER_DATA, _ALIAS_TO_CANONICAL, _CANONICAL_TO_DISPLAY
    if _ALIAS_TO_CANONICAL:
        return  # Already loaded
    try:
        with open(_DATA_FILE, "r") as f:
            _PROVIDER_DATA = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError) as e:
        print(f"WARNING: Could not load {_DATA_FILE}: {e}")
        _PROVIDER_DATA = {}

    # Load deregulated REPs
    try:
        with open(_REPS_FILE, "r") as f:
            reps_data = json.load(f)
        for rep_name, rep_info in reps_data.get("reps", {}).items():
            _REP_ALIASES[rep_name.lower()] = rep_name
            # Support optional aliases list per REP
            if isinstance(rep_info, dict):
                for alias in rep_info.get("aliases", []):
                    _REP_ALIASES[alias.lower()] = rep_name
    except (FileNotFoundError, json.JSONDecodeError) as e:
        logger.warning(f"Failed to load deregulated_reps.json: {e}")

    for canonical, entry in _PROVIDER_DATA.items():
        # New schema: entry is a dict with display_name, aliases, parent_company
        if isinstance(entry, dict):
            display = entry.get("display_name", canonical)
            aliases = entry.get("aliases", [])
            _CANONICAL_TO_DISPLAY[canonical] = display
            _ALIAS_TO_CANONICAL[canonical.lower()] = canonical
            for alias in aliases:
                _ALIAS_TO_CANONICAL[alias.lower()] = canonical
        else:
            # Old flat schema fallback: entry is a list of aliases
            _CANONICAL_TO_DISPLAY[canonical] = canonical
            _ALIAS_TO_CANONICAL[canonical.lower()] = canonical
            for alias in entry:
                _ALIAS_TO_CANONICAL[alias.lower()] = canonical

    # Build fuzzy matching index
    if _HAS_RAPIDFUZZ:
        for alias_lower in _ALIAS_TO_CANONICAL:
            norm = _normalize_for_fuzzy(alias_lower)
            if norm and len(norm) >= _SUBSTRING_MIN_LEN:
                _FUZZY_CHOICES.append(norm)
                _FUZZY_CHOICE_MAP[norm] = alias_lower
        # Also index REP names for fuzzy typo detection
        for rep_lower in _REP_ALIASES:
            norm = _normalize_for_fuzzy(rep_lower)
            if norm and len(norm) >= _SUBSTRING_MIN_LEN:
                _FUZZY_REP_CHOICES.append(norm)
                _FUZZY_REP_MAP[norm] = rep_lower


def _normalize_for_fuzzy(text: str) -> str:
    """Strip punctuation and collapse whitespace for fuzzy comparison."""
    if not text:
        return ""
    out = re.sub(r"[^a-z0-9 ]", "", text.lower())
    return re.sub(r"\s+", " ", out).strip()


# Load on import
_load_data()


def _clean_name(name: str) -> str:
    """Basic cleaning of provider name for comparison."""
    if not name:
        return ""
    cleaned = name.strip()
    cleaned = re.sub(r'\s+', ' ', cleaned)
    return cleaned


def _make_result(canonical_id, display_name, original_segment, matched,
                  is_rep=False, match_type="none", similarity=0.0, matched_on=None):
    """Build a standard result dict."""
    return {
        "canonical_id": canonical_id,
        "display_name": display_name,
        "original_segment": original_segment,
        "matched": matched,
        "is_rep": is_rep,
        "match_type": match_type,
        "similarity": similarity,
        "matched_on": matched_on,
    }


def _normalize_single(name: str) -> dict:
    """
    Normalize a single provider name segment (no commas).
    
    Matching order:
      a. Exact match on canonical_id or alias (case-insensitive)
      b. Fuzzy match (rapidfuzz, >= 85% similarity)
      c. Substring match (alias found inside input, min 4 chars)
      d. No match
    
    Returns a dict with match details including match_type and similarity.
    """
    if not name:
        return _make_result(None, "", "", False)
    
    cleaned = _clean_name(name)
    lookup = cleaned.lower()
    
    # Null/placeholder values — not provider names
    if lookup in _NULL_VALUES or not lookup:
        return _make_result(None, None, cleaned, False, match_type="null_value")
    
    # Propane delivery companies — not regulated utilities
    if lookup in _PROPANE_COMPANIES:
        return _make_result(None, cleaned, cleaned, False, match_type="propane")
    
    # Holding company names are never resolved to a child utility
    if lookup in _HOLDING_COMPANIES:
        return _make_result(None, cleaned, cleaned, False)
    
    # Deregulated market REPs
    if lookup in _REP_ALIASES:
        return _make_result(None, cleaned, cleaned, False, is_rep=True)
    
    # (a) Exact match on canonical_id or alias
    if lookup in _ALIAS_TO_CANONICAL:
        canonical = _ALIAS_TO_CANONICAL[lookup]
        display = _CANONICAL_TO_DISPLAY.get(canonical, canonical)
        return _make_result(canonical, display, cleaned, True,
                            match_type="exact", similarity=100.0, matched_on=lookup)
    
    # (b) Fuzzy match via rapidfuzz (canonical providers only — NOT REPs)
    # REP detection is strict/exact only to avoid false positives like
    # "City of Tallahassee Utilities" fuzzy-matching "frontier utilities"
    if _HAS_RAPIDFUZZ and _FUZZY_CHOICES:
        query_norm = _normalize_for_fuzzy(lookup)
        if query_norm and len(query_norm) >= _SUBSTRING_MIN_LEN:
            result = rf_process.extractOne(
                query_norm, _FUZZY_CHOICES,
                scorer=fuzz.WRatio,
                score_cutoff=_FUZZY_MIN_SCORE,
            )
            if result:
                best_match, score, _idx = result
                alias_key = _FUZZY_CHOICE_MAP[best_match]
                canonical = _ALIAS_TO_CANONICAL[alias_key]
                display = _CANONICAL_TO_DISPLAY.get(canonical, canonical)
                return _make_result(canonical, display, cleaned, True,
                                    match_type="fuzzy", similarity=round(score, 1),
                                    matched_on=alias_key)
    
    # (c) Substring match — look for a known alias embedded in the input
    if len(lookup) > _SUBSTRING_MIN_LEN:
        best_sub = None
        best_sub_len = 0
        for alias_lower, canonical in _ALIAS_TO_CANONICAL.items():
            if len(alias_lower) < _SUBSTRING_MIN_LEN:
                continue
            if alias_lower in lookup and len(alias_lower) > best_sub_len:
                best_sub = alias_lower
                best_sub_len = len(alias_lower)
                best_canonical = canonical
        if best_sub and best_sub_len >= _SUBSTRING_MIN_LEN:
            display = _CANONICAL_TO_DISPLAY.get(best_canonical, best_canonical)
            return _make_result(best_canonical, display, cleaned, True,
                                match_type="substring", similarity=0.0,
                                matched_on=best_sub)
    
    # (d) No match
    return _make_result(None, cleaned, cleaned, False)


def normalize_provider(name: str) -> str:
    """
    Normalize a provider name to its canonical form.
    
    Returns the display_name (consumer-facing brand) for the matched
    canonical provider.  Never returns a parent/holding company name.
    
    For comma-separated inputs, returns the first matched segment's display name.
    Use normalize_provider_multi() to get all matches.
    
    Args:
        name: Raw provider name from any source
        
    Returns:
        Display name for the canonical provider, or original if no mapping found
    """
    if not name:
        return ""
    
    cleaned = _clean_name(name)
    
    # If no comma, single-segment path (most common)
    if "," not in cleaned:
        result = _normalize_single(cleaned)
        return result["display_name"]
    
    # Comma-separated: try full string first (some canonical names contain commas)
    lookup = cleaned.lower()
    if lookup in _ALIAS_TO_CANONICAL:
        canonical = _ALIAS_TO_CANONICAL[lookup]
        return _CANONICAL_TO_DISPLAY.get(canonical, canonical)
    
    # Split and normalize each segment, return first match
    segments = [s.strip() for s in cleaned.split(",") if s.strip()]
    for seg in segments:
        result = _normalize_single(seg)
        if result["matched"]:
            return result["display_name"]
    
    # No segment matched, return cleaned original
    return cleaned


def normalize_provider_multi(raw_name: str) -> list:
    """
    Normalize a potentially comma-separated provider string.
    
    Splits on commas and normalizes each segment independently.
    Returns ALL matched providers (not just the first).
    
    Args:
        raw_name: Raw provider name string, possibly comma-separated
        
    Returns:
        List of dicts, each with:
            canonical_id:     canonical key (or None if unmatched)
            display_name:     consumer-facing name
            original_segment: the input segment that produced this match
            matched:          True if resolved to a canonical provider
            is_rep:           True if this is a known deregulated market REP
    """
    if not raw_name:
        return []
    
    cleaned = _clean_name(raw_name)
    
    # If no comma, single-segment path
    if "," not in cleaned:
        result = _normalize_single(cleaned)
        return [result]
    
    # Try full string first (some canonical names/aliases contain commas)
    lookup = cleaned.lower()
    if lookup in _ALIAS_TO_CANONICAL:
        canonical = _ALIAS_TO_CANONICAL[lookup]
        display = _CANONICAL_TO_DISPLAY.get(canonical, canonical)
        return [{"canonical_id": canonical, "display_name": display,
                 "original_segment": cleaned, "matched": True, "is_rep": False}]
    
    # Split and normalize each segment
    segments = [s.strip() for s in cleaned.split(",") if s.strip()]
    results = []
    for seg in segments:
        result = _normalize_single(seg)
        results.append(result)
    
    return results


def normalize_provider_verbose(raw_name: str) -> dict:
    """
    Normalize a provider name with full match details.
    
    Unlike normalize_provider() which returns just the display name string,
    this returns the complete match result including match_type, similarity
    score, and what was matched against.
    
    Args:
        raw_name: Raw provider name from any source
        
    Returns:
        Dict with:
            canonical_id:     canonical key (or None)
            display_name:     consumer-facing name
            original_segment: cleaned input
            matched:          True if resolved
            is_rep:           True if known REP
            match_type:       "exact", "fuzzy", "substring", or "none"
            similarity:       0-100 score (100 for exact, 0 for substring/none)
            matched_on:       the alias string that matched (or None)
    """
    if not raw_name:
        return _make_result(None, "", "", False)
    
    cleaned = _clean_name(raw_name)
    
    # For comma-separated, try full string first then split
    if "," in cleaned:
        lookup = cleaned.lower()
        if lookup in _ALIAS_TO_CANONICAL:
            canonical = _ALIAS_TO_CANONICAL[lookup]
            display = _CANONICAL_TO_DISPLAY.get(canonical, canonical)
            return _make_result(canonical, display, cleaned, True,
                                match_type="exact", similarity=100.0, matched_on=lookup)
        # Return the best match from any segment
        segments = [s.strip() for s in cleaned.split(",") if s.strip()]
        best = None
        for seg in segments:
            result = _normalize_single(seg)
            if result["matched"] and (best is None or result["similarity"] > best["similarity"]):
                best = result
        if best:
            return best
        # Return first segment's result if nothing matched
        if segments:
            return _normalize_single(segments[0])
        return _make_result(None, cleaned, cleaned, False)
    
    return _normalize_single(cleaned)


def get_display_name(name: str) -> str:
    """
    Get the consumer-facing display name for a provider.
    
    This is the name that should appear in API responses and UI.
    Never returns a parent/holding company name.
    
    Args:
        name: Any provider name or alias
        
    Returns:
        Display name, or cleaned original if not in database
    """
    return normalize_provider(name)


def get_canonical_id(name: str) -> Optional[str]:
    """
    Get the canonical ID (key in canonical_providers.json) for a provider.
    
    Unlike normalize_provider/get_display_name which return the display name,
    this returns the canonical key used internally for grouping.
    
    Args:
        name: Provider name to look up
        
    Returns:
        Canonical ID if found, None otherwise
    """
    if not name:
        return None
    lookup = _clean_name(name).lower()
    return _ALIAS_TO_CANONICAL.get(lookup)


def get_parent_company(name: str) -> Optional[str]:
    """
    Get the parent/holding company for a provider, if known.
    
    This is metadata only — NEVER use for matching or display.
    
    Args:
        name: Provider name to look up
        
    Returns:
        Parent company name if known, None otherwise
    """
    canonical = get_canonical_id(name)
    if not canonical:
        return None
    entry = _PROVIDER_DATA.get(canonical, {})
    if isinstance(entry, dict):
        return entry.get("parent_company")
    return None


def is_deregulated_rep(name: str) -> bool:
    """
    Check if a provider name is a known retail electric provider (REP)
    in a deregulated market.
    
    If True, the caller should return a "deregulated market" response
    instead of treating this as a matched utility provider. The actual
    TDU/EDC for the address should be used instead.
    
    Args:
        name: Provider name to check
        
    Returns:
        True if this is a known REP name
    """
    if not name:
        return False
    lookup = _clean_name(name).lower()
    return lookup in _REP_ALIASES


def get_deregulated_rep_info(name: str) -> Optional[dict]:
    """
    Get info about a deregulated market REP, if the name matches one.
    
    Returns:
        Dict with is_rep, rep_name, market, note — or None if not a REP
    """
    if not name:
        return None
    lookup = _clean_name(name).lower()
    rep_name = _REP_ALIASES.get(lookup)
    if not rep_name:
        return None
    return {
        "is_rep": True,
        "rep_name": rep_name,
        "market": "ERCOT",
        "note": "Address-based TDU lookup required"
    }


def providers_match(name1: str, name2: str) -> bool:
    """
    Check if two provider names refer to the same provider.
    
    Args:
        name1: First provider name
        name2: Second provider name
        
    Returns:
        True if they're the same provider (after normalization)
    """
    if not name1 and not name2:
        return True
    if not name1 or not name2:
        return False
    
    # Normalize both and compare
    norm1 = normalize_provider(name1) or ""
    norm2 = normalize_provider(name2) or ""
    
    if not norm1 or not norm2:
        return False
    
    if norm1 == norm2:
        return True
    
    # Also check if normalized versions contain each other
    n1_lower = norm1.lower()
    n2_lower = norm2.lower()
    
    if n1_lower in n2_lower or n2_lower in n1_lower:
        return True
    
    return False


def get_canonical_name(name: str) -> Optional[str]:
    """
    Get the canonical name for a provider, or None if not in our database.
    
    Args:
        name: Provider name to look up
        
    Returns:
        Canonical name if found, None otherwise
    """
    if not name:
        return None
    
    lookup = _clean_name(name).lower()
    canonical = _ALIAS_TO_CANONICAL.get(lookup)
    if canonical:
        return _CANONICAL_TO_DISPLAY.get(canonical, canonical)
    return None


# Quick test
if __name__ == "__main__":
    test_pairs = [
        ("PG&E", "Pacific Gas & Electric Company"),
        ("Southern California Edison", "SCE"),
        ("NIPSCO", "Northern Indiana Pub Svc Co."),
        ("Xcel Energy", "PSC of Colorado"),
        ("ComEd", "Commonwealth Edison Co."),
        ("DTE Energy", "DTE Electric Company"),
        ("PSEG", "Public Service Elec. & Gas Co."),
        ("Tampa Electric", "TECO Energy"),
        ("Georgia Power", "Georgia Power Co."),
    ]
    
    print("Provider Normalizer Test")
    print(f"Loaded {len(_PROVIDER_DATA)} canonical providers, "
          f"{len(_ALIAS_TO_CANONICAL)} total entries")
    print("=" * 60)
    
    for name1, name2 in test_pairs:
        match = providers_match(name1, name2)
        norm1 = normalize_provider(name1)
        norm2 = normalize_provider(name2)
        status = "✓ MATCH" if match else "✗ NO MATCH"
        print(f"{status}: '{name1}' vs '{name2}'")
        print(f"         Normalized: '{norm1}' vs '{norm2}'")
        print()
    
    # Test parent_company is metadata only
    print("Parent Company Metadata:")
    for name in ["NV Energy", "MidAmerican Energy", "WE Energies", "Georgia Power", "PG&E"]:
        parent = get_parent_company(name)
        display = get_display_name(name)
        print(f"  {name}: display=\"{display}\", parent={parent or '—'}")
